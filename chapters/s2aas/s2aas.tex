\chapter{When Your Device Earns Money: S\textsuperscript{2}aaS on the Bitcoin Blockchain}
\label{sec:s2aas}


\section{Context and Motivation}

In 2016, there are about 6.4 bn connected devices, 4 bn of them are in possession of individuals and private households \parencite{Gartner2015}. In 2020, the number is expected to surpass 20 bn \parencite{Gartner2015}. In addition, there are currently more than 3.4 bn smartphone subscriptions globally, and even in developing countries the adoption of smartphones has surpassed the adoption of mobile phones \parencite{Ericsson2016}. Connectivity and computing is spreading around the globe faster and more pervasive than energy grids and clean water. Smartphones are the largest sensing platform the world has ever seen. A multitude of physical and virtual sensors allow to digitize an ever more precise portrayal of the context the device, and its user, exists in. This allows applications to provide the user the services and information that are relevant for her \emph{here} and \emph{now}. The \ac{IOT} extends this paradigm to ever more objects around us. Humans are augmented with sensors measuring their steps, their heartbeat, their breath, their stress levels, their interactivity and much more. Homes are augmented with sensors measuring energy consumption, air quality, temperature, and occupancy. Cities are augmented with fixed sensing infrastructure but also by cars and individuals.
However, the combination of the sensing capabilities with computing and connectivity allows the creation of digital services that can be delivered not only to the local user, but to anybody and anything around the globe at the speed of light. We expect this will eventually enable a new business model pattern called Sensing-as-a-Service (S\textsuperscript{2}aaS). 

The New Deal on Data \parencite{pentland2009reality} emphasizes that data are worth more when shared, but due to technical and legal issues most data ends up in siloed corporate databases. The New Deal further points to the need for an equivalent to property rights for data. Individuals need to be empowered to control and monetize the data they generate. 

Therefore, we propose a bottom up approach by incentivizing individual devices and their users to provide sensing capabilities on a global market, such that the collected data can be used to create the greatest economic and societal value.
The underlying infrastructure has to be open and permissionless in order to scale organically. Everyone and everything should be able to participate. Furthermore, financial incentives and competition have the potential to improve the quality and expressiveness of data. 

In this chapter, we investigate the suitability of Bitcoin to provide the basis of such an infrastructure. To this end, we discuss the most important characteristics of Bitcoin from the vantage point of a Sensing-as-a-Service (S\textsuperscript{2}aaS) infrastructure, and present the most basic building block: The concept of exchanging data for electronic cash via the Bitcoin blockchain. Based on this concept, we analyze, and derive, requirements and present a prototypical implementation. We find that Bitcoin provides an open, permissionless infrastructure with pseudonymous identification, allowing disintermediated frictionless machine-to-machine payments. Integrated cryptographic primitives can be used for authenticity, integrity and confidentiality of data exchanges. However, while the blockchain may be used as a notary service for some important data, the Bitcoin network and protocol are not suitable for data transport. Furthermore, Bitcoin's high-latency eventual consistency, the \ac{UTXO} model, and the block size limit inhibit secure trust-less micropayments in form of \emph{direct} Bitcoin transactions.
The structure of this chapter is as follows: After the presentation of a motivating example, we provide background to the S\textsuperscript{2}aaS and crowdsensing concepts (Sec. \ref{sec:s2aas_background}). In Sec. \ref{sec:s2aas_charac} the relevant Bitcoin characteristics are presented. Thereafter, we describe the concept (Sec. \ref{sec:s2aas_concept}), analyze, refine and derive requirements (Sec. \ref{sec:s2aas_analysis}). Based on this conceptual work, we present an implementation (Sec. \ref{sec:s2aas_implementation}), and evaluate the concept (Sec. \ref{sec:s2aas_eval}). The key findings and a brief discussion is provided in Sec. \ref{sec:s2aas_findings}. Sec. \ref{sec:s2aas_relatedwork} presents the related work that has been done since this work has originally been done. Finally, we end the chapter with a conclusion (Sec. \ref{sec:s2aas_conclusion}).

\subsubsection*{Motivating Example}

To illustrate the here presented concept, we use a personal connected weather station like Netatmo \parencite{netatmo} as an example. Personal weather stations are typically equipped with multiple sensors to continuously measure, for instance, temperature, humidity, wind speed, wind direction, solar radiation, and air pressure. Some even measure air pollution in terms of particulate matter, which concerns people's health. The most obvious use for this data is to inform the owner of the weather station with the data it generates. Another example for the application of measurement data from a weather station is its use to feed the control system of the owner's household heating system. For the investment into a personal weather station and heating control, its operation and maintenance, the owner gains the benefit of a well-tempered house and saves energy and money \parencite{dong2014real}. 

Clearly, there is more overall use to the data, if it is shared with others. For instance, neighbors could use the exact same data to control their heating systems, however, only given the condition that the owner of the weather station is willing to share the generated data. Even for the rather simple case of a weather station, there are many other useful applications of the data. Fitness platforms like Runkeeper\footnote{https://www.runkeeper.com} and Nike+\footnote{https://nikeplus.nike.com} could aggregate data from many owners of personal weather stations to monitor air pollution and generate running tracks with optimal air quality in real-time. Meteorologists could improve weather forecasts with the high-resolution data from many personal weather station owners. Also, researchers could use the data to track climate change \parencite{JOC:JOC1276}.

There are already enthusiasts who share their data freely and without monetary incentive, e.g. \parencite{wunderground.com}. However, to enable applications of greater use, there has to be extensive supply of sensor data from many weather stations all around the world. Arguably, this can only be achieved by providing monetary incentive to the suppliers \parencite{bohli2009initial}.

\section{Background}
\label{sec:s2aas_background}
\subsubsection*{Sensing-as-a-Service and Crowdsensing}

The Everything-as-a-Service \parencite{10.1109/MC.2011.67} paradigm originates from cloud computing \parencite{Armbrust:2010:VCC:1721654.1721672} with its Software-as-a-Service, Platform-as-a-Service, and Infrastructure-as-a-Service models. Instead that every company or individual has its own computing and software infrastructure, the infrastructure is concentrated at one or a few data centers and can be accessed globally -- and thus consumed as a service. This provides economies of scale for the provider, and low capital costs for the consumer. This model has been extremely successful, such that most computing infrastructure is provided by a small number of providers such as Amazon, Microsoft and Google. The rearrangement from capital costs to operational costs in the form of \emph{pay as you go} revenue models has led to the creation of countless start-up companies.

The S\textsuperscript{2}aaS model is different in the sense that the resource is (often) unique. Sensing is specific to a particular context. A weather station measures the temperature at a specific location and at a specific time. A virtual sensor, measuring the installed applications on a smartphone, is specific to an individual and a time. On the other hand, S\textsuperscript{2}aaS allows to provide these unique resources globally as a service, and is the basis of a multi-sided market for sensor data \parencite{fleisch2014business}.
\cite{Perera:2014iz} provides a discussion of the applications in the context of smart cities and presents a number of benefits of the model. The main points thereby are the reduction of data acquisition costs and the availability of data that has been unavailable before.

S\textsuperscript{2}aaS may entail wireless sensor networks operated by companies, but also connected consumer devices. That latter concept is also often termed \emph{crowdsensing}. \cite{ganti2011mobile} define the term as "where individuals with sensing and computing devices collectively share data and extract information to measure and map phenomena of common interest" \parencite{ganti2011mobile}. Predominately, crowdsensing has been engaged in the form of mobile crowdsensing, utilizing the ubiquity of smartphones, in application-specific scenarios. Examples are transit tracking \parencite{Thiagarajan:2010:CTT:1869983.1869993}, road and traffic monitoring \parencite{Mohan:2008:NRM:1460412.1460444}, site characterization \parencite{Chon:2012:ACP:2370216.2370288}, and on-street parking \parencite{Chen:2012:COS:2386958.2386960,6569416}. Besides these small-scale academic field studies, notable examples for successful large-scale, application specific mobile crowdsensing application are Google Maps and Waze\footnote{https://www.waze.com/} which was acquired by Google in 2013.   

\cite{guo2015mobile} providess an extensive recent review of the various mobile crowdsensing paradigms, their applications, as well challenges and opportunities. 
The main challenges that have been identified repeatedly (see also \parencite{he2015privacy}) are privacy and incentives. \parencite{Christin2015} provides an analysis of the privacy implications and threats, as well as a survey of available privacy-preserving techniques. 

In the application-specific scenario participants are typically incentivized by receiving an application-specific service. In the case of Google Maps, a participant gets routing and traffic information in exchange for providing location and speed information. Especially in the case of participatory sensing where explicit user input is required, gamification \parencite{Deterding:2011:GDE:2181037.2181040} has been used successfully to incentivize participation (e.g. Waze). However, incentivization by service provision leads to contributions only from users who are in need of that particular service, and only during specific times. In contrast, monetary incentives are a general purpose incentive mechanism. Thus far, monetary incentives have mostly been studied in small-scale, localized field studies, as well as in form of game-theoretic incentive mechanism design \parencite{7101300}. 

In recent years, a multitude of, predominantly cloud-based, architectures enabling general purpose crowdsensing and S\textsuperscript{2}aaS applications have been presented \parencite{6558754,6525603,giannotti2012planetary,Haderer2015,merlino2016mobile}. However none of them has reached reasonable scale.

What has been mainly neglected is how monetary incentives can be provided efficiently under the conditions of a global platform. 
Individual rewards are rather small and data requesters as well as data providers might be distributed globally. Furthermore traditional online payment mechanisms provide additional means for de-anonymization of participants.
Hence, we investigate the application of Bitcoin, a global peer-to-peer cryptocurrency.

\section{Bitcoin Characteristics with Relevance to S\textsuperscript{2}aaS}
\label{sec:s2aas_charac}

Bitcoin is more than just a currency. It is programmable money and a permissionless public platform for innovation based on cryptographic primitives and mechanism design. This section presents characteristics of Bitcoin with relevance to S\textsuperscript{2}aaS and motivates the concept and implementation provided in the later sections.

\subsection{Global, Permissionless and Censorship-resistant}

Comparable to \ac{HTTP} as a protocol for transfer of data, cryptocurrencies can be viewed as a protocol for the transfer of value on the Internet. It is based on a decentralized design and consequently has no single point of failure and no single point of trust. Just like \ac{HTTP}, anyone is free to use it and build applications on top of it. This has important ramifications for its use in S\textsuperscript{2}aaS applications. For data exchange it is important that two clients are using a common protocol and data format. The same is true for value exchange. Bitcoin is by far the most pervasive, secure, and stable cryptocurrency (from a protocol perspective as well as from a exchange value perspective).

Cryptocurrencies are based on peer-to-peer networks and novel anonymous consensus protocols like the proof-of-work-based Nakamoto consensus protocol. Consensus nodes (miners) can join and leave the network at any time without notice and permission, and without any identification. This is the basis for censorship-resistance. If one miner tries to exclude a transaction, another one will be greedy enough to step in and include the transaction to take the fees. Consequently, no central authority can systematically exclude someone or something from participating. This represents a crucial difference to classical payment networks (e.g. Visa, MasterCard, or PayPal) that can ban anyone from using their services (as happened to Wikileaks in 2010 and Russian bank customers in 2014). Using Bitcoin as payment layer for S\textsuperscript{2}aaS applications brings censorship-resistance to sharing sensor data. Nobody and nothing could systematically be excluded to buy or sell data.

Without counterparty risk of an intermediary to process both payments and data transfer, applications leveraging on a Bitcoin enabled S\textsuperscript{2}aaS  environment do not carry the risk of self-interested (even justified) policy changes by central entities. For instance, policy changes by Twitter forced some third-party developers using the Twitter \ac{API} to shut down their operations \parencite{twitterAPI}. Something like this cannot happen using Bitcoin, as there is no central authority able to change the rules out of self-interest. Using Bitcoin as a payment network is completely platform independent. This should give entrepreneurs, sensor data providers (like the personal weather station owners in the example), and established platforms alike confidence in the stability, longevity and availability of S\textsuperscript{2}aaS services built on top of the Bitcoin protocol and stir innovation.

\subsection{Pseudonymous Identification}

A viable S\textsuperscript{2}aaS network requires that all entities have to be uniquely identified and authenticated. Cryptocurrencies rely on public key cryptography for authentication. Addresses, or account numbers are self-assigned and derived from cryptographic public keys. Therefore, ownership of an address is provable with public key cryptography and allows for pseudonymous authentication of sensor data.

As soon as an address is credited with at least one bit of value, i.e. 1 satoshi in the case of Bitcoin, the address is stored on the blockchain, and thus replicated across all nodes of the network.

As Bitcoin addresses are not directly connected to an identity and do not need to be registered at some central entity in the network, they guarantee pseudonymity of the owner. This can be favorable for S\textsuperscript{2}aaS applications, because data providers may not want to expose their identity. However, it does not necessarily mean that owners are anonymous. As all transactions are publicly available on the block chain, any payment can be traced to an address that can possibly be connected to an identity at some point (c.f. Sec. \ref{sec:crypto_chall_privacy}).

Bitcoin addresses cannot only be assigned to persons and used as an equivalent to a bank account. Objects like cars, fridges, houses and - like in the example -- personal weather stations -- can have a Bitcoin address, effectively enabling them to send and receive money. As the Bitcoin network does not incorporate any intermediaries, Bitcoin transactions can be carried out completely automated. In fact, Bitcoin transactions can be carried out equally well by machines and humans enabling direct machine-to-machine payments.

\subsection{Low Fees and Friction}

Cryptocurrencies are in principle arbitrarily divisible. Bitcoin is currently divisible down to 8 decimal places. Ethereum is divisible down to 18 decimal places. 
Thereby, Bitcoin can, in principle, scale down payments to very low amounts allowing for trade of very small exchangeable units. It can be expected that low fees and friction in the Bitcoin payment network can lead to a whole wave of \ac{IOT} innovations, because the programmatic exchange of arbitrary amounts of cash without human intervention and intermediaries allows for a generation of \ac{IOT} applications that has not been feasible before.

Using Bitcoin technology as a payment network for S\textsuperscript{2}aaS applications may allow for purchases of single data points, costing way less than the smallest available units of any traditional currency. This would not be possible using traditional payment networks, at least not without the introduction of additional processes. Typical intermediaries in a classical payment network like Visa, MasterCard collect fees of one to three percent \parencite{chakravorti2003theory}. Average fees for international payments (e.g. with Western Union or MoneyGram) even account for more than eight percent of the transaction amount \parencite{remittances}. Even Internet-native payment company PayPal already considers payments below \$10 as micropayments\footnote{\url{https://www.paypal.com/us/webapps/mpp/merchant-fees}}, and the fees for micropayments are 5\% + \$0.05 in June 2016. Hence, for payments below \$1 the fees are at least 10\%, and payments on the order of cents are not viable.

Bitcoin transactions are not free either, but rather compete against each other for space in the blockchain in something similar to a bidding process. Senders of Bitcoin transactions can include a voluntary, so called miner fee with their transactions. Transactions with higher fees are given higher priority by miners and are consequently processed faster than transactions with lower fees. By exposing Bitcoin transactions to these simple supply and demand market dynamics transaction costs are no longer dictated by the gatekeepers of payment networks and price efficiency in the processing of transactions for all types of applications will eventually be established.

\subsection{Programmability}
\label{subsec:script}

Cryptocurrencies introduced the concept of programmable money.
Bitcoin is programmable money in the sense that transactions are scriptable. For instance, the validity of a transaction, and hence its clearing, can be bound to certain conditions. By combining multiple transaction messages and conditions, rather complex contracts, requiring no trust between the parties, can be established. Traditionally such contracts have been enforced by intermediaries. Bitcoin allows to establish contracts and enforce them completely without intermediaries. The instruction set of Bitcoin script is restricted on purpose, but it contains powerful cryptographic primitives. On the other hand, Ethereum's instruction set is Turing-complete and the programming model is much more convenient. However, this approach has been shown repeatedly to give rise to an increasing number of attack vectors. 

An example, which exemplifies the power of the scriptability of Bitcoin for data payments is the concept of \ac{ZKCP} \parencite{maxwell2016zk,cryptoeprint:2016:451}. It combines hash-locked Bitcoin transactions with an external zero-knowledge proof-verification protocol in order to atomically bind the payment with the release of these particular data. \cite{maxwell2016zk} explains the concept as follows: ``\ac{ZKCP} is a transaction protocol that allows a buyer to purchase information from a seller using Bitcoin in a manner which is private, scalable, secure, and which does not require trusting anyone: the expected information is transferred if and only if the payment is made. The buyer and seller do not need to trust each other or depend on arbitration by a third party''. However, sensor data is typically not suitable for \ac{ZKCP} because generating and verifying the proofs is a computational intensive task.

\subsection{Cryptographic Verifiability}

Bitcoin uses digital signatures to prove ownership of bitcoins. Using the same technique, persons, or in this case sensors, can authenticate themselves by signing a message, proving ownership of their Bitcoin address. This means data can be readily authenticated proving integrity to a buyer. Certificates provided and signed by the manufacturer of the sensor could assert capabilities of the sensor. A buyer can then verify that the data originated from a sensor with the particular capabilities as attested by the manufacturer.

Confidentiality of the data to be sent can be guaranteed by encrypting the data with the public key of the receiver. However, encryption using (asymmetric) public key cryptography is much less efficient than symmetric encryption. Thus, in practice more complex protocols such as Diffie-Hellman key exchange \parencite{ISI:A1976CQ59200001} have to be used.

\subsection{Immutability and Timestamping}

Proof-of-work blockchains are (practically) immutable, tamper-evident append-only logs. This is useful to publish important public data. After publishing data to the blockchain, the data gets globally replicated. This provides high availability. Due to the immutability and append-only structure of the blockchain, published data inherits this immutability and obtains a publicly verifiable timestamp. Although the timestamp might not be exact, it provides an absolute time ordering of published data. 

In many applications data should not be public and should thus not directly get published to the blockchain. Assume the example of a connected car which continuously logs mileage data. The owner of the car does not want to publicly publish the data, but might need to prove to his insurance or to a party interested in buying the car that the current mileage has not been tampered with. Instead of directly publishing the data $m$ to the blockchain, the car blinds the data first by calculating a secure hash $M=H(m|s)$\footnote{We assume that $m$ and $s$ are in a specified, unambiguous encoding.} where $s$ is a random bit string with appropriate entropy and $|$ denotes concatenation, and publishes $M$. An observer is not able to learn anything about $m$ by knowing $M$ because secure hash functions are one-way functions. The random bit string $s$ prevents that an observer is able to infer $m$ by trial and error. At a later time, the car (or its owner) can prove that the mileage has not been changed afterwards by presenting that the transaction containing $M$ is in a particular block (providing a rough timestamp), and by presenting $m$ and $s$. 

\begin{table}\footnotesize
  \centering
  \begin{tabularx}{\textwidth}{ p{2.5cm}  X }
    \toprule
    Characteristic & Description \\
    \midrule
    Global, Permissionless, Censorship-resistant & Everyone and everything can participate \\ 
    Pseudonymous Identification & Sensors and requesters do not need a continuous identity  \\ 
    Low Fees and Friction & No human involvement and competition instead of gatekeepers \\  
    Programmability & Transactions contain tiny programs to condition payments and to enable shared control \\  
    Cryptographic Verifiability & Built-in cryptographic primitives enable authentication, data integrity and confidentiality \\ 
    Immutability and Timestamping & Proof-of-work blockchain is a decentralized timestamping service that can be used as a notary service for important data \\
    \bottomrule
  \end{tabularx}
  \caption{Characteristics of Bitcoin with relevance to S\textsuperscript{2}aaS.}
  \label{tbl:sensors}
\end{table}

Table \ref{tbl:sensors} provides a summary of the presented characteristics with a concise description. These characteristics motivate the application of Bitcoin as a basic layer of economic interactions in the context of S\textsuperscript{2}aaS. The most basic element of this interaction is the concept of exchanging a single datum for electronic cash using Bitcoin.

\section{Concept: Exchanging Data for Cash using Bitcoin}
\label{sec:s2aas_concept}

Consider the scenario in which two machines trade a single datum for cash. The simplified process is illustrated in Figure \ref{fig:btcDataExchange}. Given the example above, the requesting machine A could be the Nike+ smartphone application which requires the current air pollution at the user's typical running track to optimize air quality during the run. The sensor C in this case would be an air pollution sensor in the vicinity of the running track. Both, the requesting machine and the sensor have a key pair which provides unique identification and allows them to transfer cash as well as private data over the blockchain B as the decentralized public ledger. 
In the illustrated scenario, the requesting machine A sends a payment to the Bitcoin address of sensor C. This involves the generation of a transaction that gets included in the blockchain (1). In a second step, sensor C notices the receipt of the payment (2). After that, sensor C creates a transaction to the Bitcoin address of requester A, including its most current datum encrypted with A's public key (3). Finally, requester A notices the receipt of the transaction that includes the requested datum and decrypts it using its private key (4).

\begin{figure}
\centering
\includegraphics[width=\textwidth]{./externalized/btcpro3.png}
\caption{Schema for the basic S\textsuperscript{2}aaS process of exchanging a single datum for cash using Bitcoin.}
\label{fig:btcDataExchange}
\end{figure}

\subsection{Analysis and Requirements}
\label{sec:s2aas_analysis}

\subsubsection{Analysis}
In the basic concept, we suggest the Bitcoin blockchain as the sole medium of exchange. Both payment and data is \emph{transferred} via the blockchain. However, the blockchain is essentially a replicated append-only log that provides the basis for inferring ownership of bitcoins. Thus, \emph{transfer} is equivalent to the respective clients noticing state changes due to the inclusion of relevant transactions into blocks.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{./externalized/bitcoin_client.png}
\caption{Simplified functional structure of a Bitcoin client. A client can be divided into a networking part and a wallet. The wallet is responsible to keep track spendable coins (\ac{UTXO}s) as well as the creation and signing of transactions.}
\label{fig:btcClient}
\end{figure}


In order to interact with the Bitcoin network directly, requester and sensor have to run a Bitcoin client (c.f. Fig. \ref{fig:btcClient}). The standard client software, Bitcoin Core, implements a full Bitcoin node. Thus, it validates and relays all transactions that are broadcasted to the network. In order to validate the transactions, it keeps a full copy of the blockchain (more than 85 GB in late 2016). Requirements for storage, but also communication and computation are thus exceeding the capabilities of many \ac{IOT} devices.

Let us observe the required functionalities. We assume the requester knows the Bitcoin address $S$ of the sensor and the price $p$ of the data. In the first step of the concept, the requester creates a \ac{P2PKH} transaction that pays $p$ to $S$. Therefore, the requester needs to select $n$ \ac{UTXO}s with a values $v_i$ $i \in {1,n}$ such that $\sum_{i,1,n}v_i\ge p$. These \ac{UTXO}s will provide the input for the transaction. In addition, the requester has to add at least one output with value $p$ redeemable by the sensor. If the value of the combined inputs exceeds $p$, then the requester will add another output to credit itself with the change. Finally, the requester provides the signatures for the inputs and broadcasts the transaction.

In step (2), the sensor needs to learn about the payment transaction. Instead of being a regular peer on the network, the sensor can opt to only receive transactions involving its own address(es). Full Bitcoin nodes accept filters to serve this requirement. After the payment transaction propagates through the network and the sensor has received the transaction, the sensor can prepare the data transaction. Therefore, the sensor creates a transaction with a Null-Data output:

\begin{lstlisting}
OP_RETURN <data>
\end{lstlisting}

However, a transaction with just a Null-data output is not valid. Furthermore, the requester needs to be aware of the data transaction. In order to satisfy both requirements, the sensor provides a small payment $\epsilon$ back to the requester by providing inputs with \ac{UTXO}s surpassing $\epsilon$ and adding an \ac{P2PKH} output with value $\epsilon$, spendable by the requester. The sensor provides signatures for the input(s) of the data transaction and broadcasts it to the network. Similar to the sensor, the requester needs in principle only to know about transactions involving its address(s). After some time the requester will receive the transaction from a connected node and is able to parse the data. This concludes the process. 

\subsubsection{Deriving Requirements}
\label{sec:s2aas_requirements}

Recapitulating the process we find that requester and sensor need the following functionalities:
\begin{itemize}
\item Receive transactions involving specific addresses (Communication).
\item Store \ac{UTXO}s that are redeemable (Storage).
\item Calculate (\ac{ECDSA}) signatures (Computation).
\item Broadcast transactions (Communication).
\end{itemize}
Furthermore, we find that the actual price $p$ the requester is paying needs to be at least $p'=p+\epsilon$.  
We can also conclude that typical connected products including sensors are capable of providing the aforementioned functionalities. Typical wallet software or wallet libraries (e.g. Bitcore\footnote{\url{https://github.com/bitpay/bitcore}} (JavaScript), 21\footnote{\url{https://github.com/21dotco/two1-python}} (Python), Bitcoinj\footnote{\url{https://github.com/bitcoinj/bitcoinj}} (Java)) can be used to implement functionalities (2)-(3). Functionalities (1) and (4) need either a communication with the Bitcoin network or a mediating web service has to be used. Communication with the Bitcoin network adds some overhead but is necessary to be immune against censorship, single points of failure, and web service deprecation.

\section{Implementation}
\label{sec:s2aas_implementation}

\subsection{System Overview}

An overview of the system architecture is depicted in Figure \ref{fig:s2aasImplementation}. The main components are the requester client, a sensor client, and the Bitcoin network itself (c.f. Fig. \ref{fig:btcDataExchange}). In addition, we introduce a central repository. In the preceding discussion, we have assumed that the requester already knows the Bitcoin address of the sensor. The central repository provides a means for a requester to find sensors. In the following, we describe the main components in more detail. 


\begin{figure}
\centering
\includegraphics[width=\textwidth]{./externalized/s2aas_architecture.pdf}
\caption{Architecture of the S\textsuperscript{2}aaS implementation. Besides requester and sensor, a repository is implemented to register, query, and rate sensors.}
\label{fig:s2aasImplementation}
\end{figure}



\subsection{Requester}

The requester client is implemented as a node.js\footnote{\url{https://nodejs.org/}} application and provides a human user interface in form of a web application, which is run locally. The web application interfaces with the \ac{REST} \ac{API} of the central repository to query sensors of interest. The repository returns \ac{JSON} document including the Bitcoin address of the sensor and the price of a measurement. We use the Bitcore JavaScript libraries to interact with the Bitcoin network, and to create the payment transaction. After broadcasting the payment transaction the requester waits for the data transaction. After receiving the data transaction, the requester may rate the sensor using the repository web service. 

\begin{figure}
\begin{lstlisting}[basicstyle=\ttfamily\small]
{     
    "name": "Air Quality Zurich Downtown"
    "datatype" : "int",
    "type"     : "co2",
    "unit"     : "ppm",
    "price"    : 10,
    "location" : "47.37246913,8.54426892"
    "description": "Zurich air quality measurements"

}
\end{lstlisting}
\caption{Example of meta data for an air quality sensor.}
\label{fig:meta_data}
\end{figure}


\subsection{Sensor}
\label{sec:s2aas_implement_sensor}

The sensor is built based on a Raspberry Pi\footnote{\url{https://www.raspberrypi.org/}} embedded Linux computer. The actual sensor is a CO${_2}$ air quality sensor. The Raspberry Pi runs a node.js application similar to the requester client. However, without a graphic user interface. In the prototypical implementation a configuration file specifies the meta data (see Fig. \ref{fig:meta_data}). On first start, the sensor client creates a new key pair and derives a Bitcoin address. The address gets added to the meta data object and embedded into a \ac{JSON} web token entailing a signature created by the private key \parencite{rfc7515}. This web token is used to register with the repository.

The sensor client implements a \emph{Data transaction builder} function which creates a data transaction based on the most recent measurement. The transaction builder function is called upon the arrival of a payment function.

\subsection{Repository}

The repository is essentially a bulletin board that sensors can use to advertise their services and requesters can use to find sensors. However, the repository is not required, and is not involved in the actual S\textsuperscript{2}aaS process. The repository is based on a MongoDB\footnote{\url{https://www.mongodb.com/}}, a document-oriented database, and a \ac{REST} \ac{API} with a custom authentication layer. As described in Sec. \ref{sec:s2aas_implement_sensor}, sensors register by providing a signed web token. This allows to authenticate the sensor, if it wants to update the entry in the repository, e.g. to update the price. Furthermore, the repository could require a proof of exchange from the requester together with a potential rating. 


\section{Evaluation}
\label{sec:s2aas_eval}

We evaluate the concept and its implementation based on the following criteria:
\begin{itemize}
	\item Latency
	\item Transaction costs
    \item Viability of small payments
    \item Hardware Requirements
\end{itemize}


\subsection{Latency and Double-spending Risk}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{./externalized/s2aa2_process.pdf}
\caption{Duration of the various steps of the S\textsuperscript{2}aaS process. Data based on \parencite{Karame:2012:DFP:2382196.2382292,croman2016scaling}}
\label{fig:s2aasDuration}
\end{figure}

In order to give a rough estimate for the duration of a typical S\textsuperscript{2}aaS process, we divide the process into its basic components and consider them separately. Fig. \ref{fig:s2aasDuration} provides a graphical representation of the main components, as well as a rough estimate of the duration of each component. Creating and signing a transaction takes a few hundred milliseconds on a typical CPU. After broadcasting a transaction to the Bitcoin network, it takes on average 1-3 s until it reaches a specific node. In principle, the sensor could immediately prepare and broadcast the data transaction, and the data would reach the requester within 5 s approximately. However, accepting a so called \emph{zero confirmation} transaction involves a significant risk to get defrauded by a double-spending attack. In other words, the requester could simultaneously create and broadcast another transaction spending the same \ac{UTXO}s and crediting itself.
In order to decrease the risk of a double-spending attack, the sensor should wait until the transaction is at least included in a block. If we assume the available space in a block is much larger than the size of transactions on the network within the time between two blocks, then it should take 5 min on average until a transaction is included in a block. However, this assumption is currently not true as discussed in Sec. \ref{sec:btc_scalability}. In contrast, there might be a significant transaction backlog. In this case, the probability of inclusion is highly dependent on the attached transaction fee, which miners can claim by including the transaction into a block. We will discuss transaction costs in the next section in more detail.
On the one hand, we can assume that in a typical S\textsuperscript{2}aaS task a timely delivery of a measurement is very important. This means a latency of 5 min or more is inhibiting. On the other hand, a requester does not lose anything by trying to double-spend, since it is able to create a new identity, if the double-spend is noticed. 

One way to mitigate the risk is to add a rating system for requesters. A sensor would only accept a zero confirmation payment if the requester's rating is sufficient. A sensor could rate a requester by providing proof of a successful transaction or by proving a double-spending attack. These proofs can be provided by presenting the signed transactions. The repository can ensure itself by checking with the blockchain. 

\subsection{Transaction Costs}
\label{sec:s2aas_eval_tc}

As indicated in the last section, transactions typically have to include a fee to get considered by miners. In particular because block space has become scare. Miners \emph{have to} make a selection which transactions to include, and this selection is rationally done by considering the fees they are able to claim. Furthermore, the reference implementation Bitcoin core includes a rule for transaction relaying. If the included transaction fee is too low, the transaction might not get relayed by nodes in the network. This is a measure against \ac{DoS} attacks, by which the network gets flooded by low value transactions in order spam the network and the blockchain, and as such increase the costs for nodes.
The minimum relay fee is a adjustable parameter, but the default is set to 1000 satoshi\footnote{\url{https://github.com/bitcoin/bitcoin/blob/master/src/main.h}}.

In Bitcoin, data size matters. Block space is scarce (c.f. Figure \ref{fig:blocksize_btc}), and data is what has to be communicated with all nodes, and eventually stored in the blockchain. Thus, transaction costs are proportional to the byte size of the transaction instead of its monetary value. While this is beneficial for the transfer of large monetary value, it is an issue for low-value transactions as encountered in the S\textsuperscript{2}aaS setting. In the following, we will look at the typical size of our \emph{payment transactions} and \emph{data transactions} in order to provide a estimate for the typical transaction costs of the data for electronic cash exchange.

\begin{figure}
  \centering
    \centering\includegraphics[width=\textwidth]{./externalized/blocksize.pdf}
    \caption{Daily averages of the size of Bitcoin blocks. Space in blocks has become increasingly scare.}
    \label{fig:blocksize_btc}
\end{figure}

\paragraph{Payment Transaction}
The payment transaction needs at least one input and has most probably two \ac{P2PKH} outputs. One for crediting the sensor and one for the change, since typically there is no \ac{UTXO} available that covers the needed amount exactly.
We assume that the \ac{UTXO} that will be consumed as the input to the transaction is a \ac{P2PKH} output as well.
Based on the protocol definition in the source code\footnote{\url{https://github.com/bitcoin/bitcoin/blob/src/primitives/transaction.h}}, we can infer that a Bitcoin transaction is comprised of the fields listed in Table \ref{tbl:datasize}.

\begin{table}
\resizebox{\textwidth}{!}{%
	\begin{tabularx}{\textwidth}{ l  l  X  }
		\toprule
		Field & Description & Size [Bytes] \\
		\midrule
		nVersion &  Transaction version & 4\\
		vin & Vector of inputs & 1 + variable (if \textless 255 inputs) \\
		vout & Vector of outputs & 1 + variable (if \textless 255 outputs) \\
		nLockTime & Lock time & 4 \\
		\bottomrule
	\end{tabularx}
}
\caption{Data fields of a Bitcoin transaction and their sizes.}
\label{tbl:datasize}
\end{table}

Each input consists of a 36 byte reference to the output being consumed, a 4 byte sequence field, a scriptSig and a 1 byte (in our case) script length field. The scriptSig to spend a \ac{P2PKH} is 72 byte for the signature plus 33 byte for the public key. This adds up to 146 byte per input. Each output consists of a 8 byte value field, the pubScript, and again a 1 byte script length field. As discussed in Sec. \ref{sec:tx}, a \ac{P2PKH} pubScript consists of 4 op codes (3 bytes each) and a 20 byte Bitcoin address. Hence, each output contributes 33 bytes, and the total transaction size in bytes of a \ac{P2PKH} transaction can be calculated as follows:

\begin{equation*}
size_{Tx} = 10+146*n_{in}+33*n_{out}
\end{equation*}

With $n_{in}=1$ and $n_{out=2}$ we get 222 bytes as the minimal size of a payment transaction.

\paragraph{Data Transaction}
The data transaction needs at least one input, two \ac{P2PKH} outputs and one Null-Data output. The Null-Data output's pubScript consists of one op code (4 bytes) and a maximum of 80 bytes of data. Consequently, the size of the payment transaction is:

\begin{equation*}
\begin{split}
size_{DataTx}(data) = 10+146*2+33*2+8+1+3+bytes(data) \\ 
= 380+bytes(data)
\end{split}
\end{equation*}

Noteworthy, Bitcoin core only relays transaction with a maximum of one Null-Data output. Thus, the payload of the data transaction is limited to 80 bytes. While this is sufficient for a measurement value, it is an issue for encrypting the measurement value. A single measurement might be 2 to 8 bytes. If we include a compressed timestamp (e.g. elapsed seconds since midnight) another 2 bytes would be needed. Encrypting the measurement value using \ac{ECIES}, which is based on the cryptographic infrastructure Bitcoin natively provides, however, leads to payloads greater than 80 bytes.

Taking both transactions together, we get a minimal size of 610 byte. In Figures \ref{fig:tx_fees_btc} and \ref{fig:tx_fees_usd} we show the monthly average of transaction fees paid in mBTC/kB and USD/kB. The blue lines are trend lines. The exchange rate data is provided by the CoinDesk Price Index\footnote{\url{http://www.coindesk.com/price/}}. We see that that the average transaction fees/kB have surpassed \$0.1, i.e. the process would cost at least 6 cents.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[t]{0.5\linewidth}
    \centering\includegraphics[width=0.95\textwidth]{./externalized/txfeesmonthlybtckb.pdf}
    \caption{Monthly average of transaction fees paid in mBTC/kB.
    \label{fig:tx_fees_btc}}
  \end{subfigure}%
  \begin{subfigure}[t]{0.5\linewidth}
    \centering\includegraphics[width=0.95\textwidth]{./externalized/txfeesmonthlyusdkb.pdf}
    \caption{Monthly average of transaction fees paid in USD/kB.
    \label{fig:tx_fees_usd}}
  \end{subfigure}
  %\caption{Comparison between individual payment channels between buyers and sellers, and a hub and spoke architecture based on mediated payment channels. The number of channels can be decreased from N x M to N + M.}
\end{figure}

\subsection{Minimal Payment and Dust Limit}

Bitcoin is divisible to eight decimal places. Thus, with an exchange rate of around \$ 650 per bitcoin an individual transaction can in principle transfer value of less than 1 mCents. Above, we saw that the transaction costs are already surpassing this value by a factor of more than 1000. Another problem is the so called \emph{dust limit}. If we consider a sensor that gets paid for individual measurements, then we expect that the sensor will get a large number of tiny individual payments. Instead of accumulating money in one account, the \ac{UTXO} model of Bitcoin leads to large collection of individual \ac{UTXO}s with tiny amounts of value. Every \ac{UTXO} included in a transaction adds 33 byte and thus the necessary fees on the order of hundreds of satoshis. Hence, spending \ac{UTXO}s below a certain value costs more fees than the actual value. Thus, receiving a payment below this dynamic limit, is of no use.

The Bitcoin core wallet calculates the dust limit as follows:
\begin{equation*}
L_{Dust} = 546*minRelayTxFee/1000
\end{equation*}

With a default minRelayTxFee of 1000 satoshis, we get a dust limit of around 0.5 cents.

\subsection{Hardware Requirements}

From the requirement analysis in Sec. \ref{sec:s2aas_requirements}, we can infer that the sensor needs to run a \ac{SPV} node to connect to the Bitcoin network, and to request transactions concerning its address(es). \ac{SPV} nodes retrieve and store only block headers. Block headers in Bitcoin have a fixed size of 80 bytes. With an average block generation rate of $\frac{1}{10 min}$, we get an average communication and storage requirement of 11.52 kB per day, or 4.2 MB per year. Each payment adds at least another 222 bytes for the transaction itself, and $log_2(2000)*32=351$ bytes for the merkle branch in order to prove the inclusion of the transaction in a particular block. The number 2000 in the logarithm is the typical number of Bitcoin transactions in a single block, and 32 bytes is the size of a transaction Id. These merkle proofs can be deleted later on. Furthermore, block header data could be pruned on a regular basis.

Computationally, the most demanding task is to calculate signatures. \ac{ECDSA} is an efficient digital signature scheme than can run on restricted devices \parencite{fi3010031}. Notably, for \ac{ECDSA} the signature operation is faster than the verify operation. Since we rely on \ac{SPV}, the sensor does only need to do the signature operation and not the verify operation. Signature creation takes less than 0.5 s on a typical low-power constrained \ac{IOT} microprocessor such as the ARM Cortex-M0 \parencite{ecdsaarm}. Thus, the hardware requirements are met by a typical connected device and further optimizations are possible.

\section{Discussion}
\label{sec:s2aas_findings}

In this section we synthesize the findings of Sec. \ref{fig:s2aasImplementation} and Sec. \ref{sec:s2aas_eval}.

\paragraph{Low Latency comes with security risk}

Although transactions propagate the network in a matter of seconds Bitcoin's consensus process provides only eventual consistency. Conflicting transactions will eventually be resolved, but practical finality may only achieved on the order of tens of minutes. In many cases, sensor data is time critical. Thus, a sensor requiring practical payment finality before releasing data might not be competitive. On the other hand, if the sensor does not wait for a confirmation by the network, a malicious requester could perform a double-spending attack. 

\paragraph{Low Friction but High Transaction Costs}

Bitcoin payments can be completely automated. If a transaction is included in a block with sufficient depth, a machine can be sure that it has control over the coins. Just like a vending machine can be sure as soon as someone inserts a coin.  All other forms of online payments can be disputed and reverted, and the owner or some delegated third party service has to take care -- adding friction. Thinking of billions of sensors, the traditional systems do not scale. Thus, in principle Bitcoin provides a superior basis. Nevertheless, we have seen that over the years transaction costs have risen tremendously because block size got scarce. Furthermore, the dust limits inhibits individual transaction below the order of cents.

\paragraph{Combination between on- and off-chain is needed}

The concept illustrated in Fig. \ref{fig:btcDataExchange} suggests the usage of the Bitcoin network as medium for money \emph{and} data exchange. In this case no further communication channels are needed. However, latency, transaction costs and the need for confidentiality suggest that additional means for communication are required. 

\paragraph{Decentralizing the repository}
In the prototypical implementation, we introduced a centralized repository that provides a means for discovery between sensors and requesters. Authentication based on Bitcoin's public key cryptography provides built-in integrity of the records, and as soon as a requester knows about the existence of a particular sensor, the requester is not dependent on the repository anymore. The actual exchange does not depend on the repository. However, the repository may censor specific sensors, and poses a target for \ac{DoS} attacks. We believe, that a decentralized repository is not the critical part of the infrastructure, but could be implemented based on technologies like Blockstack \parencite{ali2016blockstack} or by means of a \ac{DHT} (c.f. OpenBazaar in Sec. \ref{sec:ecobazaar}).

\section{Related Work}
\label{sec:s2aas_relatedwork}

At the time we presented the concept in \parencite{DBLP:journals/corr/NoyenVWF14} and provided a first prototypical implementation \parencite{Worner:2014:YSE:2638728.2638786}, there was no work concerning the usage of cryptocurrencies to build an infrastructure for S\textsuperscript{2}aaS or other business models that benefit from machine-to-machine payments.
In this case, related work refers not to work that has already existed at the point the research was conducted and presented, but on work that has been done since then. 
Filament aims to implement the concept of S\textsuperscript{2}aaS in business and industrial settings instead of consumer devices. Direct bitcoin payments to the device will be possible, but the default model will be to have a backend service, either run by Filament or by the client company, that can issue payment receipts. These payment receipts can then be presented to the device in exchange for data. While this architecture might be suitable for sensor networks that are mainly in operation for one or a few companies, this does not scale to consumer devices with millions of individual device owners. Notably, Filament is developing a new light-weight communication protocol\footnote{\url{http://telehash.org/}} with end-to-end encryption and without the need for a centralized messaging broker. 21 Inc. provides another interesting basis for S\textsuperscript{2}aaS. They built easy to use command line tools and open source software libraries to interact with the Bitcoin network, either directly or by using propriety services provided by the 21 backend infrastructure. The libraries allow to conveniently build bitcoin-payable \ac{REST}ful \ac{HTTP} \ac{API} endpoints. There are three different payment schemes which client and server can negotiate: (1) normal bitcoin payments, (2) payment channels (see Sec. \ref{sec:paymentchannels}), and (3) so called \emph{BitTransfers}. BitTransfers are \emph{off-chain} payments with 21 Inc. as the custodian. Essentially, 21 keeps an internal ledger that is updated with every BitTransfer, allowing to transfer earned bitcoins to an \emph{on-chain} address in bulk at a later time. Conveniently, users of the 21 Inc. software typically opt-in to be part of a \ac{SDN} which allows to overcome the typical issues to connect with devices behind routers and \ac{NAT}. On the 21 Inc. overlay network all devices are addressable as if they were on a local network. This allows to establish direct communication channels between requesters and sensors. We developed a S\textsuperscript{2}aaS system based on the 21 Inc. infrastructure \parencite{worner2016design}, but the reliance on proprietary infrastructure counteracts its use as a global S\textsuperscript{2}aaS platform. More information on Filament and 21 can be found in the case studies in Appendix \ref{appendix:cases}.

Besides these industry endeavors, there has also been related work in academia. \cite{7073830} presents the concept of an \emph{IoTcoin}. Ownership of an IoTcoin allows, for example, to access data generated from a particular device. The IoTcoin is implemented using the colored coins protocol and could be issued by a sensor owner and sold to a requester. This model is essentially a way to pre-pay for the extended usage of a sensor. Thus, the IoTcoin acts like a payment aggregation. Furthermore, an IoTcoin owner is in principle able to sell the IoTcoin to another requester. However, larger upfront payments require additional trust in the sensor, and hence reinforce the need of a reputation system.

\cite{s16060776} propose the \emph{PaySense} framework which uses Bitcoin for rewards and as a reputation system. The framework introduces a \ac{DCS} and an \ac{ACA}. A sensor has to acquire a certificate from the \ac{ACA} in order to receive tasks and rewards from the \ac{DCS}. The sensor gets only paid by the \ac{DCS}, if the measurement task fulfills specific quality requirements. Hence, the payment can be interpreted as a reputation. The clever part of the system is that a sensor can transfer the reputation to a new address, i.e. a new identity, in a privacy-preserving way by using a CoinJoin-based mixing service. The system is not permissionless, since the \ac{ACA} decides which sensors to certify, but the \ac{ACA} can not link the sensor with its identity in the system. Furthermore, in principle, multiple interoperable \ac{ACA} (and \ac{DCS}) are possible. 
 

\section{Conclusion}
\label{sec:s2aas_conclusion}

The \ac{IOT} is expected to consist of billions of sensor nodes bridging the gap between the physical and digital world. Based on the idea that not only the one who generates data can profit from it, the concept of S\textsuperscript{2}aaS foresees global sensor data markets. However, to carry this idea from theory to practice, there are manifold systemic hurdles to overcome.

Individual sensor owners have to be incentivized to make their data publicly available in a well-structured and meaningful format, such that machines can automatically identify relevant data providers and procure data without human due diligence. The underlying infrastructure should be open, permissionless and censorship-resistant in order to foster participation and innovation. 

In this chapter, we identified and described characteristics of cryptocurrencies, and Bitcoin in particular, that serve the need of a global S\textsuperscript{2}aaS infrastructure. We described the concept of exchanging data for electronic cash using the Bitcoin infrastructure exclusively. Based on this concept, we implemented a prototypical system based on a sensor application and a requester application. The prototype was extended by a central repository to provide a means for discovery as well as a simple reputation system. The analysis of the concept and the evaluation of the prototype showed that cryptocurrencies are a promising economic layer for machine-to-machine payments, and S\textsuperscript{2}aaS in particular. The global and permissionless payment infrastructure allows machines to accept payments with finality, and can thus deliver service without counterparty risk. This provides a secure basis for an automated machine economy. The built-in cryptographic primitives of cryptocurrencies can be used to authenticate sensors and their measurement data to ensure integrity (\ac{ECDSA}), and can be used as a basis for confidentiality by encryption (\ac{ECIES}). Critical data can be blindly committed to the blockchain to provide an immutable proof of existence at a particular time. Moreover, S\textsuperscript{2}aaS based on cryptocurrencies may provide the missing incentives to equip connected devices with dedicated hardware for cryptographic operations and secure key storage, and make security a first class priority. 
% We found that low-power connected devices are able to provide the necessary hardware requirements to create transactions and accept proofs of payments from the network. 

In general, communication and data delivery should happen on other channels than the Bitcoin network itself. Data transfer on the Bitcoin network adds additional costs, and can not provide confidentiality due to size constraints. Furthermore, the Bitcoin network is an unstructured, dynamic network that provides resilience while sacrificing latency.

However, secure payments have high latency on the order of tens of minutes, and transaction fees have risen dramatically during the last month. These fees are proportional to the size (in bytes) of a transaction instead of their value (in bitcoins or dollars). Furthermore, the dust limit, which is related to Bitcoin's \ac{UTXO} architecture, prohibits payments below cents. Hence, low-latency micropayments which would allow a low-trust automated machine economy to flourish seem to be out of reach. In the next chapter, we will see how the programmability of Bitcoin allows to setup contracts between untrusted parties to enable Bitcoin micropayments. 


% \section{Prototype II: Datamarket based on the 21 Bitcoin Computer}

% The system is based on the 21 Bitcoin Computer which provides two important features that simplify the implementation significantly. First, a library is provided that allows to integrate Bitcoin-payable HTTP REST endpoints. Payments can either be made on- or off-chain. Off-chain payments are handled by 21 internally and therefore allow instant micropayments below Bitcoin's dust limit (currently 576 satoshi\footnote{Satoshi is the smallest fraction of a bitcoin. 1 satoshi corresponds to $10^{-8}$ bitcoin.}) and without fees. Hence, we sacrifice direct peer-to-peer payments, at least for the moment, in exchange for the possibility to handle individual payments as tiny as 1 satoshi. Second, each 21 Bitcoin Computer is already part of a virtual network enabled by software defined networking. Thus, peer-to-peer communications, e.g. for data delivery, between requesters and providers are directly possible. 

% \subsection{Architecture}

% \subsection{Implementation}

% % \begin{figure}
% % \begin{center}
% % \includegraphics[width=0.7\textwidth]{datamarket.pdf}
% % \caption{General architecture of the data market artifact.}
% % \label{fig:system}
% % \end{center}
% % \end{figure}

% \
% A graphical representation of the system is shown in figure \ref{fig:system}. In the following we will briefly describe the individual components.
% \subsubsection{Sensor registry}
% \label{sec:registry}
% The sensor registry provides the means of discovery for data providers and data requesters. Notably, discovery between requesters and providers could be implemented on top of a distributed hash table like Blockstack\cite{blockstack}. However, we chose a centralized registry based on a MongoDB for practical reasons. Data providers are able to publish their offerings on the data market by creating an entry in the sensor registry. This is currently done with the command line interface, which will be presented in Section \ref{sec:cli}. Entries in the sensor registry have the following form\footnote{Additional fields such as accuracy or measurement interval might be available.}
% \begin{lstlisting}[basicstyle=\ttfamily\tiny]
% {     
%     "name": "Air Quality Zurich Downtown"
%     "endpoint" : "http://10.147.17.77:3002/measurement",
%     "datatype" : "int",
%     "type"     : "co2",
%     "unit"     : "ppm",
%     "price"    : 10,
%     "location" : "47.37246913,8.54426892"
%     "description": "Zurich air quality measurements"

% }
% \end{lstlisting}
% and can be queried using the datamarket command line interface. Entries also have a time-to-live (TTL) after which they expire. TTL can be extended by payment. This provides a revenue stream for the data market provider and should lead to a higher fraction of available data providers. 
% \subsubsection{Data provider}
% A data provider is represented by a simple HTTP webserver with a payable API endpoint that returns a measurement value and a timestamp as JSON. Since the 21 Bitcoin Computer is essentially a Raspberry Pi physical sensors can be attached easily. Moreover it can act as bridge to external sensor data. An example would be an endpoint which is fed by a MQTT consumer.
% \subsubsection{Datamarket command line interface}
% \label{sec:cli}
% The datamarket command line interface provides access to the functions of the data market. Figure \ref{fig:cli} shows the help screen where all functions are listed. In the next section we will present a step-by-step guide through the functions.
% \begin{figure}
% \begin{center}
% \includegraphics[width=0.7\textwidth]{./externalized/cli.png}
% \caption{Help screen of the datamarket command line interface provides an overview of its functions.}
% \label{fig:cli}
% \end{center}
% \end{figure}





% \subsection{Evaluation}
% \label{sec:eval}
% In the following, we will use the datamarket artifact to offer real-time data of air quality measurements in Zurich.
% We assume a 21 Bitcoin Computer with a CO$_{2}$ sensor, which acts as a proxy for air quality, attached and the datamarket cli installed. The sensor.py represents the actual webserver that will serve the measurement data upon payment. Thus, sensor.py has to be configured to access and serve the measurement data. Furthermore the configuration file config.json which provides essentially the sensor registry entry as presented in Section \ref{sec:registry} has to be adapted. After that we are ready to publish the sensor on the data market with
% \begin{lstlisting}[basicstyle=\ttfamily\small]
% datamarket publish --hours 72
% \end{lstlisting}
% The hours option defines how long the entry will stay valid. To start up the webserver and serve measurement data to potential data requesters we type
% \begin{lstlisting}[basicstyle=\ttfamily\small]
% datamarket open
% \end{lstlisting}
% Now a potential requester can query the datamarket to find this offering by using
% \begin{lstlisting}[basicstyle=\ttfamily\small]
% datamarket query '{"type": "co2", "location:"Zurich"}'
% \end{lstlisting}
% which will return matching sensors. The current measurement value can then be bought directly from a sensor node either using the returned id or the endpoint url. Here we use the id.
% \begin{lstlisting}[basicstyle=\ttfamily\small]
% datamarket buy '56698e32961b6b64b473e71c'
% \end{lstlisting}
% If funds are sufficient the current measurement value is returned along with a timestamp.

% \section{Prototype III: Mobile Crowdsensing with Mediated Payment Channels}

% \subsection{Architecture}

% he system consists of three main components. A data requester or data buyer application, a data provider application, and a hub application. In order to fulfill the aforementioned principles the payment of the measurement data is done by means of N-to-M mediated payment channels as presented in Section \ref{sec:mediated} where the hub acts as the mediator over which payments are routed. At the same time the hub provides a query-able data provider registry. Noteworthy, the consolidation of payment routing and registry slightly violates our third design principle. However, both components are logically separated. An illustration of the system's architecture is shown in Figure \ref{fig:architecture}.


%  \begin{figure}
%  \includegraphics[width=\textwidth]{./externalized/Architecture.pdf}
%  \caption{Overview of system's architecture.}
%  \label{fig:architecture}
%  \end{figure}

% \subsection{Implementation}

% The implementation of N-to-M mediated payment channels is based on extending the payment channel implementation of the bitcoinj library \cite{Bitcoinj}. Bitcoinj is a Java library for working with the Bitcoin protocol and was the first Bitcoin library that had implemented support for payment channels. The Java implementation was chosen because it allows to reuse the implementation across all of the system's components. JavaScript provides the same benefits but libraries were not as mature at that point. Furthermore, bitcoinj implements simplified payment verification (SPV). It allows to verify on-chain transactions without needing to store and verify the entire Bitcoin blockchain. SPV nodes store only the block headers (80 byte instead of a few hundred kilo byte for a typical block), and rely on the depth of a transaction in the blockchain. Block headers contain the root of a Merkle tree that is built of all transaction hashes in the block. Hence, in order to validate a particular transaction, a SPV node has to retrieve only a subset of the block data, i.e. the corresponding branch of the Merkle tree.
% Only due to the SPV is it viable to use Bitcoin on resource constrained devices without trusting third party services.

% The data requester and the hub are implemented as native Java applications. The data provider is implemented as an Android application. Before presenting the implementation of the individual components we start with the common building block on which all peer-to-peer payments are based. 

% \paragraph{Mediated payment channels using HTLCs}

% We follow the client-server architecture of the payment channel implementation of bitcoinj \cite{BitcoinjPC}. A client is always on the sending side of a payment while a server is on the receiving side (c.f. Figure \ref{fig:architecture}). Since the hub acts as mediator or router for payments between requesters and providers it has to receive payments from requesters and forward those payments to providers. Hence, the hub incorporates both, server and client.

% \begin{table}
%   \centering
%     \caption{The five layers of the HTLC payment channel implementation.}
%   \begin{tabular}{|c|l|}
%     \hline
%     \tabhead{Layer} &
%     \tabhead{Description} \\
%     \hline
%     Driver Application & \multicolumn{1}{|p{0.5\columnwidth}|}{Provides the API to access lower layers}\\
%     \hline
%     Channel Connection & \multicolumn{1}{|p{0.5\columnwidth}|}{Provides the interface to the network}\\
%     \hline
%     Payment Channel & \multicolumn{1}{|p{0.5\columnwidth}|}{Handles messages from/to the network and passes instructions/gets results to/from the lower layer}\\
%     \hline
%     Channel State Machine & \multicolumn{1}{|p{0.5\columnwidth}|}{Handles the state of the payment channel}\\\\
%     \hline
%     HTLC State Machines & \multicolumn{1}{|p{0.5\columnwidth}|}{Handles the state of the HTLC}\\\\
%     \hline
%   \end{tabular}
%   \label{tbl:layers}
% \end{table}

% In order to implement hashed HTLCs we extended the four layers of bitcoinj's payment channel implementation with a fifth layer that is concerned with keeping track of the HTLC flow. The five layers are described briefly in Table \ref{tbl:layers}. Details about the state machines and sequence diagrams can be found in BLINDED FOR REVIEW.
% Messages and transactions are serialized using Google protocol buffers\footnote{https://developers.google.com/protocol-buffers/} and are exchanged between the components over TCP connections. The payment channel setup and the HTLC payments in the implementation are slightly more complex and involve even more communication than it is shown in Table \ref{tabl:htlcflow} because we use the interactive approach for channel refunds. 

% \paragraph{Data provider}

% The data provider is implemented as an Android application. The application allows users to offer measurement data from various sensors at an adjustable price denominated in satoshis\footnote{A satoshi is the smallest fraction of a bitcoin and corresponds to $10^{-8}$ bitcoins}. Table \ref{tbl:sensors} provides an overview of possible sensors. With the initial boot of the application, a local wallet is generated. The wallet is responsible for generating and storing key pairs and signing transactions. Furthermore a background service is started that manages the payment channel server and data delivery. If a user decides to offer measurement data from a specific sensor, the application registers the sensor at the global sensor registry. The initial registration then triggers the setup of a payment channel between the hub and the Android application. As soon as the payment channel is established the application is ready to serve requests from buyers.


% \begin{table}
%   \centering
%   \caption{Examples of virtual and physical sensors available in smartphones.}
%   \begin{tabular}{|c|l|l|}
%     \hline
%     \tabhead{Sensor} &
%     \tabhead{Type} &
%     \tabhead{Application} \\
%     \hline
%     Barometric pressure & physical & Weather prediction \\
%     \hline
%     Location & both & People flow  \\
%     \hline
%     Network strength & physical & Coverage maps \\
%     \hline
%     Installed apps & virtual & Inter-app correlations    \\
%     \hline
%     Transportation mode & virtual & City monitoring \\
%     \hline
%     Steps & virtual & Health monitoring  \\
%     \hline
%   \end{tabular}
%   \label{tbl:sensors}
% \end{table}


% \paragraph{Data requester}
% The data requester is implemented as a Java application. The requester application allows to query the sensor registry. In the prototype this is achieved using simple console commands. Table \ref{tbl:commands} shows the available commands.

% \begin{table}
%   \centering
%     \caption{Available commands of the data requester console.}
%   \begin{tabular}{|c|l|}
%     \hline
%     \tabhead{Command} &
%     \tabhead{Description} \\
%     \hline
%     STATS NODES & Returns all connected sensor nodes \\
%     \hline
%     STATS SENSORS & Returns available sensor types \\
%     \hline
%     SELECT SENSOR=$<$type$>$ & \multicolumn{1}{|p{0.5\columnwidth}|}{Returns sensors of type $<$type$>$ with pricing information} \\
%     \hline
%     BUY $<$type$>$ FROM $<$node$>$ & \multicolumn{1}{|p{0.5\columnwidth}|}{Buys the current measurement value of sensor $<$type$>$ from node $<$node$>$} \\
%     \hline
   
%     \hline
%   \end{tabular}
%   \label{tbl:commands}
% \end{table}



% \paragraph{Hub}
% The hub acts as the central point of coordination. Data providers register their sensors with the sensor registry that the hub provides, and data requesters are able to query the registry. Furthermore, the hub is responsible for mediating the payments between buyers and sellers. The hub instantiates a payment channel client and a payment channel server

% \subsection{Evaluation}

% \subsubsection{Conceptual Evaluation}

% \paragraph{Low barrier for participation}
% A potential participant on the data provider side has to download and install the data provider smartphone application. The data provider does not need to own any bitcoins. Furthermore no manual sign-up or registration is required. This means also the system has global reach and could provide a low-income stream to smartphone users in developing countries.

% A data requester does not have to register but the wallet of the data requester application needs to have some amount of bitcoin in order to initiate a payment channel with the hub.

% \paragraph{Incentivize participation with micropayments}
% Individual payments can be as low as 1 satoshi. In April 2016, the exchange rate is around 450\$/BTC. In regard to this exchange rate individual payments can be as low as 4.5 $\mu$\$. Even smaller payments could be implemented with probabilistic payment schemes \cite{Rivest1997,Pass:2015:MDC:2810103.2813713}. Transaction fees for setting up and closing payment channels will be discussed in Sec. \ref{sec:fees}. 

% \paragraph{Limited trust in hub provider}
% The usage of HTLCs to interconnect payment channels of data providers and data requesters allows atomic payments between those parties. This means either the payment happens in both channels or it happens not at all. 

% \paragraph{Anonymity}
% Obviously there is a risk of de-anonymization for data providers depending on the data they are selling. For example selling of location data or wifi SSIDs could be used to identify a data provider. We restrict the evaluation of anonymity to the payment aspect. Bitcoin payments themselves are pseudonymous. Transactions only entail cryptographic public keys or hashes thereof. If users . In addition, due to the usage of mediated payment channels, there is no public link between buyers and sellers. Only transactions between buyers and the hub, and sellers and the hub end up in the blockchain. Transactions entailing the linking secret are kept private. 

% In addition, there is a risk of de-anonymization based on the IP addresses. However since all communications are based on TCP, it would be possibly to run the system over Tor\footnote{https://www.torproject.org/}.


% \subsubsection{Empirical Evaluation}

% \paragraph{Performance}

% For setting up and closing of payment channels the Bitcoin network itself is dictating the performance. If fees are sufficient a transaction can be assumed to be included in the blockchain in 10 min on average. Depending on the value of the transaction the receiver of the funds might wait until the transaction has six confirmations. This means that there are five additional blocks on top of the block entailing the transaction. 
% In the following we assume that payment channels are already in place and evaluate the time is takes to complete a payment. The experiment was done by instantiating 100 data requesters and one data provider. Each requester buys one measurement value from the data provider. Table \ref{tbl:performance} shows a breakdown of the mean times and the standard deviation according to the payment steps. The results request some explanation. First, the HTLC setup process between hub and provider seems to take almost twice as long as the the HTLC setup between requester and hub. The reason for this is that the hub-provider setup is initiated with generating the secret but then has to wait until requester-hub setup is finished. If the hub would initiate the HTLC setup with the provider immediately the hub would risk paying the provider without being able to pull the respective funds from the requester. Second, the teardown process (i.e. updating the setup transacting by assigning the value of HTLC output to the payee.) takes less than half the time of the setup process. The reason for that is mainly that in the actual implementation the interactive refund approach was used. This means that there is an additional transaction which has to be signed by both parties and has to be transferred from payer to payee and back. Thus, we expect a comparable performance between setup and teardown if the non-interactive approach is used. Furthermore, we see that the steps that involve the provider take more time. This is because signing and signature verification are computation intensive tasks and the data provider is a comparably weak smartphone.

% \begin{table}
% \centering
% \caption{Payment duration breakdown}
% \begin{tabular}{|l|r|r|}
% \hline
% {\textbf Payment } & \multicolumn{1}{l|}{{\textbf Mean}} & \multicolumn{1}{l|}{{\textbf St. Dev.}} \\ \hline
% Requester-Hub setup             & 479.3 ms                 & 78.8 ms                      \\ \hline
% Hub-Provider setup            & 1015.1 ms                & 151.4 ms                     \\ \hline
% Hub-Provider teardown         & 199.6 ms                 & 68.3 ms                      \\ \hline
% Buyer-Provider teardown          & 146.6 ms                 & 10.1 ms                      \\ \hline
% \end{tabular}

% \label{tbl:performance}
% \end{table} 


% \paragraph{Transaction costs}
% \label{sec:fees}
% Transaction fees in Bitcoin are in principle voluntary. The party that creates a transaction specifies the transaction fees as the difference of the sum of the value of all inputs and the sum of the value of all outputs. However, each miner can decide individually if she will accept the transaction for a candidate block. Since there is a limit on the maximum size of a block, and larger blocks need more time to propagate the network, rational miners will select transactions with higher transaction fees. This is also the reason why transaction fees are based on the size of the transaction instead of its value. The transaction size is mainly defined by the number and size of input and output scripts and signatures. Figure \ref{fig:tx_fees} shows the daily averages of transaction fees in USD/kb for the period of one year.

% \begin{figure}[!t]
% \centering
% \includegraphics[width=\textwidth]{./externalized/fees_per_kb}
% \caption{Bitcoin transaction fees in USD/kb. Each point represents a daily average.}
% \label{fig:tx_fees}
% \end{figure}


% \begin{table}
%   \centering
%   \caption{Approximate sizes and costs for Bitcoin transactions}
%   \begin{tabular}{|c|l|l|}
%     \hline
%     \tabhead{Transaction Type} &
%     \tabhead{Size} &
%     \tabhead{Cost} \\
%     \hline
%     Standard P2PKH & \multicolumn{1}{|p{0.5\columnwidth}|}{} & \\
%     \hline
%     Funding & \multicolumn{1}{|p{0.5\columnwidth}|}{} & \\
%     \hline
%     HTLC setup & \multicolumn{1}{|p{0.5\columnwidth}|}{} & \\
%     \hline
%     Settlement & \multicolumn{1}{|p{0.5\columnwidth}|}{} & \\
%     \hline
%     Forfeiture & \multicolumn{1}{|p{0.5\columnwidth}|}{} & \\
%     \hline
%   \end{tabular}
%   \label{tbl:fees}
% \end{table}



