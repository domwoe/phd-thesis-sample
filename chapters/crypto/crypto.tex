\chapter{Decentralized Cryptocurrencies and Blockchain Technology}
\label{sec:crypto}


\section{Bitcoin: The first decentralized Cryptocurrency}

 In November 2008 an e-mail with the subject: "Bitcoin P2P e-cash paper"\footnote{http://satoshi.nakamotoinstitute.org/emails/cryptography/1/} was sent to The Cryptography Mailing List. The first e-mail from sender Satoshi Nakamoto. The e-mail presents the abstract and a link to a white paper with the title "Bitcoin: A Peer-to-Peer Electronic Cash System". A few month later, On January 3rd 2009, the first instances of the Bitcoin client software began running the Bitcoin network, and Bitcoin has been running ever since. 

 As already apparent from the title of the paper, Bitcoin provides a P2P digital cash system without the reliance on a trusted third party. Since digital assets can be duplicated without cost, corresponding to the double spending problem, previous digital cash system had to rely on trusted third parties to authorize transactions centrally. These trusted third parties have therefore the ability to censor transactions, and to change the monetary policy, i.e. create new money at will. 

 In Bitcoin, double spending is prevented by having each participant taking part in a P2P network, and having each participant holding a copy of the entire ledger. Consensus over the ledger state is powered by a novel consensus protocol which involves the expenditure of a real-world physical resource. This process is also the basis to create new coins, and therefore provides a lower bound for the value of bitcoins. 

Bitcoin provides four main contributions: (1) A P2P digital cash system or the first digital bearer asset, (2) an implementation of programmable money, (3) a practically immutable publication system, and (4) a new design space for distributed systems. 

We will discuss all of these contributions in more detail. However, we will start with presenting the technological basis and how Bitcoin works in more detail.

%Great overview: \cite{Tschorsch:2015:464}
\subsection{The Technology}
\label{sec:btc_tech}

\subsubsection{Peer to Peer network}
\label{sec:p2p}

The foundation of Bitcoin is a peer-to-peer network of voluntary nodes. Each node validates, relays, and stores all (valid) transactions. Thus in Bitcoin everyone validates everything, or at least everyone is able to validate everything. In the beginning every Bitcoin \emph{user} ran a Bitcoin node, since it was the only way to keep track of and to send bitcoins. Today most users do not directly participate in the peer-to-peer network, since running a full node is becoming ever more resource intensive. At time of writing the Bitcoin network consists of approximately 5600 nodes. Nodes are distributed globally, but the majority is in Europe and the coastal areas of the US. 

\cite{DonetDonet2014}


\subsubsection{Transactions and Scripting}
\label{sec:tx}

The naming of \emph{Bitcoin} is misleading. In Bitcoin there are no coins being exchanged between parties. A coin in Bitcoin is identified by an unspent transaction output (UTXO). Transfer of ownership of coins is achieved by spending one (or more) UTXO and creating one (or more) new UTXO.
The authenticated data structure used is called a transaction. A simplified representation of a transaction is shown in Figure \ref{fig:bitcointx}. The individual data fields will be explained over the course of this section.
 A transaction contains essentially a list of inputs and outputs. Inputs reference (unspent) outputs of previous transactions, and provide a means of authentication to prove ownership over these UTXOs. Outputs are tuples entailing values, the amount denominated in satoshi, and the condition the receiver has to meet to spend the output. 

\begin{figure}
\centering
\includegraphics[width=\textwidth]{./externalized/simplifiedTx.pdf}
\caption{A simplified representation of the Bitcoin transaction data structure.}
\label{fig:bitcointx}
\end{figure}

A transaction is valid if the combined value of the inputs are greater than or equal to the combined value of the outputs, and if the conditions of the referenced previous UTXOs are met.
In the following we will take a closer look at these conditions and how transactions are authenticated. The corresponding data fields are called \emph{pubScript} and \emph{sigScript} and can contain data and op codes, i.e. programming primitives, of a constrained, stateless Forth-like stack-based scripting language called Bitcoin Script. 
When validating a transaction a node will concatenate the pubScript of a referenced output with the sigScript of a referencing input, and execute the script. A transaction can only be valid if all  scripts evaluate to \emph{true}. 

The most important op codes are related to cryptographic primitives such as digital signature verification and secure hash functions. Bitcoin currently employs an elliptic curve digital signature algorithm (ECDSA) for authentication. In the prevailing case a derivation of an ECDSA public key is identified with a Bitcoin address, and the corresponding private key is used to create a signature to authenticate the spending of an UTXO corresponding to this Bitcoin address. 
The pubScript in this basic scenario is called pay-to-pubkey-hash (P2PKH).

\begin{lstlisting}
OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
\end{lstlisting}

The sigScript that is able spend the output takes the following form:

\begin{lstlisting}
<Sig> <PubKey>
\end{lstlisting}

where $<$Sig$>$ denotes the signature corresponding to the particular transaction and the private key corresponding to the public key $<$PubKey$>$.

Concatenating and executing works as follows:

\begin{lstlisting}[breaklines]
1. <Sig> <PubKey> OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
2. <Sig> <PubKey> <PubKey> OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
3. <Sig> <PubKey> <PubKeyHash> <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
4. <Sig> <PubKey> OP_CHECKSIG
5. TRUE
\end{lstlisting}

First, OP\_DUP duplicates the operand $<$PubKey$>$. Second, OP\_HASH160 computes the SHA-256 and RIPMED-160 secure hash of $<$PubKey$>$. Third, OP\_EQUALVERIFY takes two operands and returns if they are equal. Fourth, OP\_CHECKSIG takes a signature and a public key, and returns true if the signature validation is successful. 

Bitcoin, i.e. the reference implementation Bitcoin core, currently distinguishes five types of \emph{standard} pubScripts:

\begin{itemize}
\item Pay To Public Key Hash (P2PKH)
\item Pay To Public Key (P2PK)
\item Multi-Signature 
\item Pay to Script Hash (P2SH)
\item Null data
\end{itemize}

If a pubScript can not be categorized in one of these types, it is termed \emph{non-standard}. For some time Bitcoin core nodes would not relay transactions containing non-standard pubScripts because there had been found vulnerabilities in some op codes. However, if a non-standard transaction ended up in the blockchain because a miner  (see Sec. \ref{sec:mining}) had a different policy, Bitcoin core nodes still accepted it. Today, Bitcoin core relays transactions with arbitrary non-standard pubScripts.

P2PK is similar to P2KH and not used very often since a shorter key hash is replaced by a longer public key. Multi-signature outputs demand m-of-n signatures to spend an output. However, today multi-signature is usually implemented as P2SH. P2SH is the most versatile pubScript type and thus worth discussing in more detail.

The P2SH pubScript takes the following form:

\begin{lstlisting}
OP_HASH160 <Hash160(redeemScript)> OP_EQUAL
\end{lstlisting}

Thereby, the pubScript reveals very little information about what is needed to spend the output. The spending party then has to provide a \emph{redeemScript} that hashes to the required 20 byte value. Thus, the pubScript is very small and concise, but the redeemScript in the sigScript can be up to 520 bytes (see \cite{bip16} for more information). 

An example implementing P2PK as P2SH is as follows:

\begin{lstlisting}[breaklines]
pubScript: OP_HASH160 <Hash160{<PubKey> OP_CHECKSIG}> OP_EQUAL
scriptSig: <Sig> {<PubKey> OP_CHECKSIG}
\end{lstlisting}

Null data pubScripts allow zero value outputs with 80 bytes of arbitrary data. To be standard, each transaction can only have one null data output, and needs to have at least one additional output type. Null data outputs are used for Proof-of-Publication, and as the basis for overlay protocols, as discussed later on. Null data outputs are provably unspendable. This means nodes do not need to consider them in their UTXO set, which is typically held in memory to quickly validate incoming transactions. 

The null data pubScript is as follows:
\begin{lstlisting}
OP_RETURN <data>
\end{lstlisting}

\subsubsection{The Blockchain}
\label{sec:blockchain}

 \begin{figure*}[!t]
    \centering
    \includegraphics[width=\linewidth]{./externalized/blockchain}
    \caption{Simplified structure of the Bitcoin blockchain. Each block references its predecessor by a hash pointer. The content of the gray area is the block header.}
    \label{fig:blockchain}
  \end{figure*}

In the Bitcoin system transactions are batched into a primitive called a block. A block contains the transactions as payload and a header. The header consists essentially of the root of the Merkle tree that is computed from the transaction hashes, the hash of the previous block, and a number called nonce which we will discuss in the next section. Let us assume for the moment that there is only one node in the Bitcoin network. Since each block refers to its predecessor the emergent data structure is a chain of blocks, a blockchain. Note that linking blocks by means of hash pointers leads to an tamper-evident append-only data structure. If a transaction is changed in block $i$ of a blockchain containing $n$ blocks, the chain of hashes breaks, and every hash from block $i$ to block $n$ has to be re-computed.

Therefore, a blockchain is a tamper-evident append-only transaction log that defines the current state by giving its complete history.

\subsubsection{Mining and Nakamoto Consensus}
\label{sec:mining}

The nodes that batch transactions into blocks are called miners. The reason for this terminology will become clear later in this section. Noteworthy, every participant can decide to be a miner at any time. Thus, there may be (and actually should be) more than one miner in the network, and the set of miners may change continuously. How do we get from local subjective blockchains to one global objective blockchain that implies the global state of the Bitcoin network? In terms of the science of distributed computing: How does the network achieve consensus?
The naive (local) rule is to accept the block that arrives first. However, in a distributed system with finite speed of information propagation there is no guarantee that two nodes will agree on which block arrived first. This is true even if both nodes are honest. Therefore, consensus protocols are used which involve some form of voting. In Bitcoin nodes may join or leave the network at will, and there is no notion of a reliable identity. This is important to provide censorship resistance. However, a malicious actor may spin up multiple nodes to gain more weight in the voting process. This is called a Sybil attack. The Nakamoto consensus protocol is based on the idea to couple the weight of a vote with the expenditure of a real-world physical resource. The approach is inspired by Proof-of-Work as presented in HashCash. Nodes only consider new blocks to be valid if an appropriate amount of Proof-of-Work is provided. This is operationalized as follows:

A block has to have an identifying hash that is smaller than a particular target value. Thus, a miner has to vary the block and re-compute its hash until the target is met. Therefore the consensus protocol is non-interactive and the block generation rate is a function of the combined hash rate of every mining node and the particular target or difficulty. The more hashing power an actor controls, the higher is her chance to find a block. If a node follows the Nakamoto consensus protocol it will broadcast a block as soon as the block has been found. Receiving nodes will check the validity of the transactions, and the Proof-of-work. Mining nodes will stop mining their current block, apply the new block, and start mining on top of this new block. Thereby, the chain with the highest accumulated amount of work is considered the valid chain. 

If nodes adhere to the Bitcoin mining protocol, the system is resilient against double-spending, and censorship, as long as the majority of hash power is controlled by honest nodes. \cite{Eyal2014} have shown that a \emph{rational} miner should divert to a different strategy termed \emph{selfish mining}, by which the miner withholds blocks in order to have a head-start to mine the next block, in order to get an unfair advantage. At time of writing, selfish mining has not been observed in the Bitcoin network, but in other blockchain-based cryptocurrencies. It can be argued that a rational miner should follow the selfish mining strategy to maximize her profits. However, the profits are denominated in bitcoin whereas her expenditures are probably to be paid in a national currency. Since the appearance of selfish mining could harm the Bitcoin system as a whole, and thereby have a negative effect on the bitcoin exchange rate, following the Nakamato protocol may still be the rational choice from an long-term ecosystem perspective. 

% Interestingly,elfish mining threshold coincides with the theoretical limit of malicious actors in classical consensus protocols, requiring a fixed number of participants per round, with byzantine faults. At time of this writing there is no known theoretical explanation for the coinciding thresholds in very different settings.

Why would a miner follow the Nakamoto protocol at all considering the resource intensive Proof-of-Work requirement? This question is closely related to another very intriguing question: How are bitcoins created?

The answer to both of these questions is that the Bitcoin protocol allows a miner to include one special transaction into each block, a coinbase transaction. These transactions have do not reference any previous transaction outputs, but allow the creation of new coins. The maximum accumulated value of the coinbase outputs of a particular block is fixed in the protocol and gets reduced by 50\% every 210,000 blocks. On protocol level UTXO values are integers denominated in satoshis. $10^8$ satoshis correspond to 1 bitcoin. Therefore, after 33 \emph{halvenings} the block reward becomes effectively zero because it will fall below the limit of one satoshi. In addition, the difference between the value of transaction inputs and outputs are identified as transaction fees, and can be claimed by the miner. However, in 2016, transaction fees play only a minor role which account for less than 2\% of a block reward.

In the original white paper Proof-of-work was introduced as one-CPU-one-vote. However, as the value of bitcoin appreciated, miners exploited the inherent parallelizability of the Proof-of-work algorithm and implemented it in increasing sophistication. First, on graphical processing units (GPUs), followed by field-programmable gate arrays (FPGAs), and eventually on application-specific integrated circuits (ASICs). Thereby, the energy efficiency has increased by several orders of magnitude. The implication of this evolution is that mining has become subject to economies of scale, and is only profitable with the most-recent specialized hardware, and only with access to very cheap electricity.   


%\cite{Miller:2015:NSP:2810103.2813621} non-outsourceable scratch-off puzzles 

\subsection{Fundamental Contributions}
\label{sec:btc_cont}

\subsubsection{Digital Bearer Instrument}

"A bearer instrument is a document that entitles the holder of the document rights of ownership or title to the underlying property" \cite{bearer}, i.e. there is no central record of ownership. Because of the duplication or double spending issue there had not been a way to create digital bearer instrument. Ownership of an unique digital asset had always been augmented by a trusted third party. Bitcoin is the first digital bearer instrument. Possession of the private keys or redeemScripts ensures ownership and permissionless control over the corresponding coins.

Noteworthy, it is straight forward to implement registered instruments in Bitcoin, e.g. using multi-signature outputs that require the signature of a trusted third party. However it is impossible to implement a true digital bearer instruments based on a system administered by centralized third party.

\subsubsection{Programmable Money}

The notion of programmable money has two aspects from the perspective of Bitcoin. First, the existence of Bitcoin Script allows to couple the spending of coins to various conditions. The most versatile method is the usage of multi-signature outputs in combination with oracles. Oracles are services that sign transactions based on some conditions, and can be used to condition payments on off-chain events. Second, due to the nature of bitcoins being digital bearer instruments, machines with access to secure key storage are able to make payments autonomously.  

\subsubsection{Immutable, Censorship-resistant Publication System}

Bitcoin's solution to the double spending problem is the approximation of a logically centralized timestamping server with a decentralized P2P network that is maintaining a replicated tamper-evident transaction log with a consensus rule based on the largest accumulated amount of Proof-of-Work. Transactions that have been added to the blockchain become increasingly expensive to revert. Hence, data that is added to a transaction, e.g. by using a null data output as discussed in Sec. \ref{sec:tx}, which ends up in the blockchain becomes publicly notarized, and with every additional block, censorship becomes more expensive. Hence, Bitcoin provides a practically immutable open access global publication system.

\subsubsection{A New Design Space for Distributed Systems}

Bitcoin can be used as a platform to build distributed applications on top. The foundations for this are Bitcoin as programmable money and Bitcoin as an immutable publication system. In addition Bitcoin has been the basis for an emerging field typically termed Blockchain Technology or Distributed Ledger Technology. This incorporates alternative cryptocurrencies, but also P2P networks designed for other applications. One of the main inspiration thereby is the introduction of economic incentives on protocol level. 

\subsection{Open Challenges}
\label{sec:btc_challenges}

Although Bitcoin has repeatedly exceeded a market capitalization of \$ 10 billion it has still to be viewed as an experiment with unknown outcome. Bitcoin faces a multitude of challenges in various fields. Besides the technical challenges, there are also challenges concerning usability/comprehensibility, governance, legal status, law enforcement, and even environmental impact. 

\subsubsection{Scalability}

\subsubsection{Privacy}

\subsubsection{Governance}

\subsubsection{Environmental Footprint}

\subsubsection{Illicit Usage}


\subsection{A Look at the Ecosystem}


%\section{OPTIONAL: The Cambrian Explosion of Cryptocurrencies}

\section{Ethereum: Towards the World Computer}

Every state transition is authenticated 

\cite{Luu:2015:DIC:2810103.2813659} verifier's dilemma

\subsection{History and Current State}

\subsection{Comparison with Bitcoin}

\subsection{Smart Contracts}

\subsection{Applications}

%\section{OPTIONAL: Private Blockchains or Distributed Databases}

%\section{OPTIONAL: Consensus in Distributed Systems}

%\section{From Chains to Braids}

%\section{Participation}

\section{A comparison}

\section{Discussion}

\section{Conclusion}

%\section{Interfacing Blockchains}

%\subsection{Full Nodes}
%Full nodes take part in 

%\subsection{Thin Clients}

%\subsection{Web Services}

% Internet status quo: Trust requirement into the service provider and dependency on a central system

% Trust in crypto alone might be problematic since crypto could be broken some day.

% Classic paper for security in DHTs is Sit et al. 2002. One key issue found is \emph{verification of node keys} that can be mitigated by a solution based on authentication.

% MaidSafe uses username and password to self-authenticate. Data is stored self-encrypted in the network and nodes that store data proved by Proof-of-Resource are get paid in Safecoins. (When do I have to pay Safecoins? How do Safecoins get value?) 

% \section{Further reading}
% \cite{Bonneau2015,Tschorsch:2015:464}